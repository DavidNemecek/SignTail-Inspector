      pageRefs: new Map(),
    function makeRefKey(ref) {
      if (!ref || typeof ref.num !== 'number' || typeof ref.gen !== 'number') {
        return null;
      }
      return `${ref.num}:${ref.gen}`;
    }

    function extractReferenceArray(body, key) {
      const results = [];
      if (typeof body !== 'string') {
        return results;
      }
      const arrayRegex = new RegExp(`\/${key}\\s*\\[([^\\]]+)\\]`, 'g');
      let match;
      while ((match = arrayRegex.exec(body))) {
        const refsRaw = match[1];
        const refRegex = /(\d+)\s+(\d+)\s+R/g;
        let refMatch;
        while ((refMatch = refRegex.exec(refsRaw))) {
          results.push({ num: parseInt(refMatch[1], 10), gen: parseInt(refMatch[2], 10) });
        }
      }
      return results;
    }

    function extractIndirectReferences(body) {
      const results = [];
      if (typeof body !== 'string') {
        return results;
      }
      const refRegex = /(\d+)\s+(\d+)\s+R/g;
      let match;
      while ((match = refRegex.exec(body))) {
        results.push({ num: parseInt(match[1], 10), gen: parseInt(match[2], 10) });
      }
      return results;
    }

      state.pageRefs.clear();
          if (page.ref) {
            state.pageRefs.set(pageNumber - 1, page.ref);
          }
      const pageRefToIndex = new Map();
      for (const [pageIndex, ref] of state.pageRefs.entries()) {
        const key = makeRefKey(ref);
        if (key !== null) {
          pageRefToIndex.set(key, pageIndex);
        }
      }
      if (!pageRefToIndex.size && doc) {
        const total = doc.numPages || 0;
        for (let pageNumber = 1; pageNumber <= total; pageNumber++) {
          try {
            const page = await doc.getPage(pageNumber);
            const key = makeRefKey(page.ref);
            if (key !== null) {
              pageRefToIndex.set(key, pageNumber - 1);
            }
          } catch (error) {
            console.warn('Failed to cache page reference', pageNumber, error);
          }
        }
      }

      const indirectToPage = new Map();
      for (const [key, pageIndex] of pageRefToIndex.entries()) {
        indirectToPage.set(key, pageIndex);
      }

      for (const obj of objects) {
        const objKey = makeRefKey({ num: obj.objNum, gen: obj.generation });
        if (objKey && pageRefToIndex.has(objKey)) {
          const pageIndex = pageRefToIndex.get(objKey);
          indirectToPage.set(objKey, pageIndex);
          const annotRefs = extractReferenceArray(obj.content, 'Annots');
          for (const ref of annotRefs) {
            const refKey = makeRefKey(ref);
            if (refKey) {
              indirectToPage.set(refKey, pageIndex);
            }
          }
        }
      }

      for (const obj of objects) {
        const objKey = makeRefKey({ num: obj.objNum, gen: obj.generation });
        if (!objKey || !indirectToPage.has(objKey) || obj.type !== 'annotation') {
          continue;
        }
        const pageIndex = indirectToPage.get(objKey);
        const relatedRefs = extractIndirectReferences(obj.content);
        for (const ref of relatedRefs) {
          const refKey = makeRefKey(ref);
          if (refKey && !indirectToPage.has(refKey)) {
            indirectToPage.set(refKey, pageIndex);
          }
        }
      }

            const ref =
              typeof pdfjsLib.Ref === 'function' ? new pdfjsLib.Ref(obj.pageRef.num, obj.pageRef.gen) : obj.pageRef;
        if (!resolved) {
          const objKey = makeRefKey({ num: obj.objNum, gen: obj.generation });
          if (objKey && indirectToPage.has(objKey)) {
            obj.pageIndex = indirectToPage.get(objKey);
            resolved = true;
          }
        }
